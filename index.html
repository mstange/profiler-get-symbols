<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<title>profiler get symbols wasm test page</title>

<body>

<script src="profiler_get_symbols.js"></script>

<p>Binary: <input type="file" id="binary"></p>
<p>Debug: <input type="file" id="debug"></p>
<p>Breakpad ID: <input type="text" id="breakpadId" size="40"></p>

<p><input type="button" value="Gather the symbols and print the result to the web console" onclick="doStuff()"></p>

<script>

const { CompactSymbolTable, WasmMemBuffer, get_compact_symbol_table } = wasm_bindgen;

const request = new Request('./profiler_get_symbols_bg.wasm', {
  // integrity: 'sha384-Be8HpV3ZILuaRRaIUATA+L3btsLWEE+ocnKh5UAZ1/Odvs5xF3u5BheCz5fMhOAw'
});

WebAssembly.compileStreaming(fetch(request)).then(module => {
  return wasm_bindgen(module);
}).catch(error => {
  console.error(error);
});

function getFileResultOrUndefined(fileInput) {
  return new Promise((resolve, reject) => {
    if (!fileInput.files[0]) {
      resolve();
      return;
    }
    const fileReader = new FileReader();
    fileReader.readAsArrayBuffer(fileInput.files[0]);
    fileReader.onload = function () {
      resolve(fileReader.result);
    };
    fileReader.onerror = function () {
      resolve();
    };
  }).catch(() => {});
}

async function doStuff() {
  const binaryFileResult = await getFileResultOrUndefined(document.querySelector("#binary"));
  const debugFileResult = await getFileResultOrUndefined(document.querySelector("#debug"));

  if (!binaryFileResult) {
    return;
  }

  const binaryData = new WasmMemBuffer(binaryFileResult.byteLength, array => {
    array.set(new Uint8Array(binaryFileResult));
  });
  let debugData = binaryData;
  if (debugFileResult) {
    debugData = new WasmMemBuffer(debugFileResult.byteLength, array => {
      array.set(new Uint8Array(debugFileResult));
    });
  }

  const breakpadId = document.querySelector("#breakpadId").value;

  try {
    const output =
        get_compact_symbol_table(binaryData, debugData, breakpadId);

    const [addr, index, buffer] = [output.take_addr(), output.take_index(), output.take_buffer()];
    output.free();
    console.log(`Received symbol table with ${addr.length} symbols:`);
  } catch (e) {
    console.error("Caught exception:", e);
  }

  binaryData.free();
  if (debugData != binaryData) {
    debugData.free();
  }
}

function symbolTableToSymbolMapObj([addr, index, buffer]) {
  const textDecoder = new TextDecoder();
  const mapObj = {};
  for (let i = 0; i < addr.length; i++) {
    mapObj[`0x${addr[i].toString(16)}`] = textDecoder.decode(buffer.subarray(index[i], index[i + 1]));
  }
  return mapObj;
}

function printFromRust(phrase) {
  console.log(phrase);
}

function readFileInto(file, dataBuf) {
  // Ideally we'd be able to call file.readTo(dataBuf) here, but readTo no
  // longer exists.
  // So instead, we copy the file over into wasm memory in 4MB chunks. This
  // will take 425 invocations for a a 1.7GB file (such as libxul.so for a
  // Firefox for Android build) and not take up too much memory per call.
  const dataBufLen = dataBuf.byteLength;
  const chunkSize = 4 * 1024 * 1024;
  let pos = 0;
  while (pos < dataBufLen) {
    const chunkData = file.read({ bytes: chunkSize });
    const chunkBytes = chunkData.byteLength;
    if (chunkBytes === 0) {
      break;
    }

    dataBuf.set(chunkData, pos);
    pos += chunkBytes;
  }
} 

// helper callback function for symbolicate testing, currently not implemented
// in index.html to test the function. 
async function passBuffer(candidatePath, debugPath) {
  console.log(`passBuffer is called: I got ${candidatePath} and ${debugPath} from Rust`);
  const binaryFileResult = await getFileResultOrUndefined(document.querySelector("#binary"));
  const debugFileResult = await getFileResultOrUndefined(document.querySelector("#debug"));
  if (!binaryFileResult) {
    console.log(`binaryFileResult is empty`);
    return;
  }
  const binaryData = new WasmMemBuffer(binaryFileResult.byteLength, array => {
    array.set(new Uint8Array(binaryFileResult));
  });
  let debugData = binaryData;
  if (debugFileResult) {
    debugData = new WasmMemBuffer(debugFileResult.byteLength, array => {
      array.set(new Uint8Array(debugFileResult));
    });
  }

  const breakpadId = document.querySelector("#breakpadId").value;
  return new BuffersWrapper(
    binaryData, 
    debugData,
    breakpadId
  );
  }

// helper callback function for symbolicate testing, currently not implemented
// in index.html to test the function. 
class BuffersWrapper {
  constructor (binaryData, debugData, debugId) {
    this.binaryData = binaryData;
    this.debugData = debugData;
    this.debugId = debugId;
  }

  getInnerDebugData() {
    return this.debugData;
  }

  getInnerBinaryData() {
    return this.binaryData;
  }

  getInnerDebugID() {
    return this.debugId;
  }
}

</script>